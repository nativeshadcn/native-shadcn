{
  "name": "sheet",
  "type": "ui",
  "description": "A bottom sheet component",
  "dependencies": [
    "clsx",
    "@gorhom/bottom-sheet"
  ],
  "devDependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "ui/sheet.tsx",
      "content": "import * as React from 'react';\nimport { Modal, View, Pressable, Text, Animated, PanResponder, Dimensions } from 'react-native';\nimport { cn } from '@/lib/utils';\n\nconst { height: SCREEN_HEIGHT } = Dimensions.get('window');\n\ntype SheetContextValue = {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n};\n\nconst SheetContext = React.createContext<SheetContextValue | undefined>(undefined);\n\ntype DraggableContextValue = {\n  panHandlers: any;\n};\n\nconst DraggableContext = React.createContext<DraggableContextValue | undefined>(undefined);\n\nfunction useSheet() {\n  const context = React.useContext(SheetContext);\n  if (!context) {\n    throw new Error('Sheet components must be used within <Sheet>');\n  }\n  return context;\n}\n\nfunction useDraggable() {\n  return React.useContext(DraggableContext);\n}\n\ninterface SheetProps {\n  open?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  children?: React.ReactNode;\n}\n\nconst Sheet = ({ open = false, onOpenChange, children }: SheetProps) => {\n  const [internalOpen, setInternalOpen] = React.useState(open);\n\n  const isControlled = open !== undefined && onOpenChange !== undefined;\n  const currentOpen = isControlled ? open : internalOpen;\n  const handleOpenChange = isControlled ? onOpenChange : setInternalOpen;\n\n  const contextValue = React.useMemo(\n    () => ({\n      open: currentOpen,\n      onOpenChange: handleOpenChange,\n    }),\n    [currentOpen, handleOpenChange]\n  );\n\n  return (\n    <SheetContext.Provider value={contextValue}>\n      <Modal\n        visible={currentOpen}\n        transparent\n        animationType=\"slide\"\n        onRequestClose={() => handleOpenChange(false)}\n      >\n        {children}\n      </Modal>\n    </SheetContext.Provider>\n  );\n};\n\nconst SheetTrigger = React.forwardRef<\n  React.ElementRef<typeof Pressable>,\n  React.ComponentPropsWithoutRef<typeof Pressable>\n>(({ onPress, ...props }, ref) => {\n  const { onOpenChange } = useSheet();\n\n  return (\n    <Pressable\n      ref={ref}\n      onPress={(e) => {\n        onOpenChange(true);\n        onPress?.(e);\n      }}\n      {...props}\n    />\n  );\n});\nSheetTrigger.displayName = 'SheetTrigger';\n\nconst SheetOverlay = React.forwardRef<\n  React.ElementRef<typeof Pressable>,\n  React.ComponentPropsWithoutRef<typeof Pressable>\n>(({ className, onPress, ...props }, ref) => {\n  const { onOpenChange } = useSheet();\n\n  return (\n    <Pressable\n      ref={ref}\n      className={cn('absolute inset-0 bg-black/50', className)}\n      onPress={(e) => {\n        onOpenChange(false);\n        onPress?.(e);\n      }}\n      {...props}\n    />\n  );\n});\nSheetOverlay.displayName = 'SheetOverlay';\n\ninterface SheetContentProps extends React.ComponentPropsWithoutRef<typeof View> {\n  draggable?: boolean;\n  minHeight?: number;\n  maxHeight?: number;\n  initialHeight?: number;\n  snapPoints?: number[];\n  onHeightChange?: (height: number) => void;\n}\n\nconst SheetContent = React.forwardRef<\n  React.ElementRef<typeof View>,\n  SheetContentProps\n>(({\n  className,\n  children,\n  draggable = false,\n  minHeight = 200,\n  maxHeight = SCREEN_HEIGHT * 0.75,\n  initialHeight,\n  snapPoints,\n  onHeightChange,\n  ...props\n}, ref) => {\n  const defaultInitialHeight = initialHeight || (draggable ? minHeight : undefined);\n  const sheetHeight = React.useRef(new Animated.Value(defaultInitialHeight || minHeight)).current;\n  const startHeight = React.useRef(defaultInitialHeight || minHeight);\n\n  // Get snap points (either custom or default min/max)\n  const getSnapPoints = React.useCallback(() => {\n    if (snapPoints && snapPoints.length > 0) {\n      return snapPoints.sort((a, b) => a - b);\n    }\n    return [minHeight, maxHeight];\n  }, [snapPoints, minHeight, maxHeight]);\n\n  // Find nearest snap point\n  const findNearestSnapPoint = React.useCallback(\n    (currentHeight: number, velocity: number) => {\n      const points = getSnapPoints();\n\n      // If velocity is strong, snap in that direction\n      if (velocity < -0.5) return points[points.length - 1]; // Fast swipe up -> max\n      if (velocity > 0.5) return points[0]; // Fast swipe down -> min\n\n      // Find nearest snap point\n      return points.reduce((nearest, point) => {\n        return Math.abs(point - currentHeight) < Math.abs(nearest - currentHeight)\n          ? point\n          : nearest;\n      }, points[0]);\n    },\n    [getSnapPoints]\n  );\n\n  const panResponder = React.useRef(\n    PanResponder.create({\n      onStartShouldSetPanResponder: () => draggable,\n      onMoveShouldSetPanResponder: (_, gestureState) => {\n        return draggable && Math.abs(gestureState.dy) > 5;\n      },\n      onPanResponderGrant: () => {\n        startHeight.current = (sheetHeight as any)._value;\n      },\n      onPanResponderMove: (_, gestureState) => {\n        if (!draggable) return;\n\n        const newHeight = startHeight.current - gestureState.dy;\n\n        // Allow movement within bounds with resistance\n        if (newHeight >= minHeight && newHeight <= maxHeight) {\n          sheetHeight.setValue(newHeight);\n        } else if (newHeight < minHeight) {\n          sheetHeight.setValue(minHeight - (minHeight - newHeight) * 0.3);\n        } else if (newHeight > maxHeight) {\n          sheetHeight.setValue(maxHeight + (newHeight - maxHeight) * 0.3);\n        }\n      },\n      onPanResponderRelease: (_, gestureState) => {\n        if (!draggable) return;\n\n        const currentHeight = (sheetHeight as any)._value;\n        const targetHeight = findNearestSnapPoint(currentHeight, gestureState.vy);\n\n        Animated.spring(sheetHeight, {\n          toValue: targetHeight,\n          useNativeDriver: false,\n          damping: 25,\n          stiffness: 120,\n          mass: 0.8,\n        }).start(() => {\n          onHeightChange?.(targetHeight);\n        });\n      },\n    })\n  ).current;\n\n  if (!draggable) {\n    // Original non-draggable behavior\n    return (\n      <View className=\"flex-1 justify-end\">\n        <View\n          ref={ref}\n          className={cn(\n            'rounded-t-3xl bg-background p-6 shadow-lg min-h-[50%]',\n            className\n          )}\n          {...props}\n        >\n          {children}\n        </View>\n      </View>\n    );\n  }\n\n  // Draggable behavior\n  const draggableContextValue = React.useMemo(\n    () => ({ panHandlers: panResponder.panHandlers }),\n    [panResponder]\n  );\n\n  return (\n    <View className=\"flex-1 justify-end\">\n      <Animated.View\n        ref={ref}\n        style={{\n          position: 'absolute',\n          bottom: 0,\n          left: 0,\n          right: 0,\n          height: sheetHeight,\n        }}\n        className={cn('rounded-t-3xl bg-background shadow-lg', className)}\n        {...props}\n      >\n        <DraggableContext.Provider value={draggableContextValue}>\n          {children}\n        </DraggableContext.Provider>\n      </Animated.View>\n    </View>\n  );\n});\nSheetContent.displayName = 'SheetContent';\n\ninterface SheetDragHandleProps extends React.ComponentPropsWithoutRef<typeof View> {}\n\nconst SheetDragHandle = React.forwardRef<\n  React.ElementRef<typeof View>,\n  SheetDragHandleProps\n>(({ className, ...props }, ref) => {\n  const draggable = useDraggable();\n\n  return (\n    <View\n      ref={ref}\n      {...(draggable?.panHandlers || {})}\n      className={cn('items-center py-3', className)}\n      {...props}\n    >\n      <View className=\"w-12 h-1 bg-muted-foreground/30 rounded-full\" />\n    </View>\n  );\n});\nSheetDragHandle.displayName = 'SheetDragHandle';\n\nconst SheetHeader = React.forwardRef<\n  React.ElementRef<typeof View>,\n  React.ComponentPropsWithoutRef<typeof View>\n>(({ className, ...props }, ref) => (\n  <View ref={ref} className={cn('mb-4 text-center', className)} {...props} />\n));\nSheetHeader.displayName = 'SheetHeader';\n\nconst SheetTitle = React.forwardRef<\n  React.ElementRef<typeof Text>,\n  React.ComponentPropsWithoutRef<typeof Text>\n>(({ className, ...props }, ref) => (\n  <Text\n    ref={ref}\n    className={cn('text-lg font-semibold text-foreground text-center', className)}\n    {...props}\n  />\n));\nSheetTitle.displayName = 'SheetTitle';\n\nconst SheetDescription = React.forwardRef<\n  React.ElementRef<typeof Text>,\n  React.ComponentPropsWithoutRef<typeof Text>\n>(({ className, ...props }, ref) => (\n  <Text\n    ref={ref}\n    className={cn('text-sm text-muted-foreground text-center', className)}\n    {...props}\n  />\n));\nSheetDescription.displayName = 'SheetDescription';\n\nconst SheetClose = React.forwardRef<\n  React.ElementRef<typeof Pressable>,\n  React.ComponentPropsWithoutRef<typeof Pressable>\n>(({ onPress, ...props }, ref) => {\n  const { onOpenChange } = useSheet();\n\n  return (\n    <Pressable\n      ref={ref}\n      onPress={(e) => {\n        onOpenChange(false);\n        onPress?.(e);\n      }}\n      {...props}\n    />\n  );\n});\nSheetClose.displayName = 'SheetClose';\n\nexport {\n  Sheet,\n  SheetTrigger,\n  SheetOverlay,\n  SheetContent,\n  SheetDragHandle,\n  SheetHeader,\n  SheetTitle,\n  SheetDescription,\n  SheetClose,\n};\n",
      "type": "registry:ui"
    }
  ]
}